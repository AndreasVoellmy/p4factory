/****************************************************************
 *
 * DO NOT EDIT THIS FILE: See below
 *
 * This file is copied into the target's top level directory for
 * all P4 programs. If you edit this file locally (in a P4 directory)
 * the changes will be lost. If you edit this file in targets/common,
 * the changes will apply to all targets.
 *
 * To change this behavior, edit targets/common/common.mk.
 *
 * main for thrift based protocol dependent layer based on
 * P4 program from p4-params.mk at top level of repository
 *
 ***************************************************************/

#include <unistd.h>
#include <sys/types.h>

#include <AIM/aim_log.h>
#include <uCli/ucli.h>
#include <BigList/biglist.h>

#include <bfns_common/ctl_messages.h>
#include <bfns_common/bfns_db.h>
#include <bfns_common/bfns_utils.h>

#include <SocketManager/socketmanager.h>
#include <common/portmanager.h>

#include <getopt.h>
#include <assert.h>
#include <signal.h>

#include <p4_sim/rmt.h>
#include <pd_thrift/bfn_pd_rpc_server.h>

#include <pthread.h>

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

static biglist_t *interfaces = NULL;
static uint64_t dpid = 0;
static char *listener_str = NULL;
static char *datapath_name = "bfns";
static char *bfnsdb_str = NULL;
static char *pd_server_str = NULL;
static int no_cli = 0;
static int dump_pcap = 1;
static bfns_tcp_over_ip_t bfnsdb_addr;
static bfns_tcp_over_ip_t listener_addr;
static bfns_tcp_over_ip_t pd_server_addr;
static bool no_veth = false;

pthread_t ctl_listener_thread;

extern ucli_module_t* lg_pd_ucli_module_create(void);

/**
 * The maximum number of ports to support:
 * @fixme should be runtime parameter
 */
#define PORT_COUNT 256
#define PD_SERVER_DEFAULT_PORT 9090

struct sigaction old_action_SIGTERM;
struct sigaction old_action_SIGINT;


/**
 * Check an operation and return if there's an error.
 */
#define CHECK(op)                                                       \
    do {                                                                \
        int _rv;                                                        \
        if ((_rv = (op)) < 0) {                                         \
            fprintf(stderr, "%s: ERROR %d at %s:%d",                    \
                    #op, _rv, __FILE__, __LINE__);                      \
            return _rv;                                                 \
        }                                                               \
    } while (0)

#ifdef LIBL2L3_ENABLE
extern int bf_api_init(int);
extern int start_bfn_api_rpc_server(void);
#endif /* LIBL2L3_ENABLE */

#ifdef NETLINK_ENABLE
extern int start_bfnl_server(void);
#endif /* NETLINK_ENABLE */

static int add_port(char *iface, uint16_t port_num) {
  fprintf(stderr, "switch is adding port %s as %u\n", iface, port_num);
  if(bfm_port_interface_add(iface, port_num, datapath_name, dump_pcap) < 0)
    return CTL_MSG_STATUS_ERROR;
  return CTL_MSG_STATUS_SUCCESS;
}

static int del_port(char *iface) {
  fprintf(stderr, "switch is deleting port %s\n", iface);
  if(bfm_port_interface_remove(iface) < 0) return CTL_MSG_STATUS_ERROR;
  return CTL_MSG_STATUS_SUCCESS;
}

static int send_status_reply(int client, uint64_t request_id, int status) {
  ctl_msg_status_t msg;
  msg.code = CTL_MSG_STATUS;
  msg.request_id = request_id;
  msg.status = status;
  sendall(client, (char *) &msg, sizeof(ctl_msg_status_t));
  return 0;
}

static int process_add_port(int client) {
  ctl_msg_add_port_t msg;
  msg.code = CTL_MSG_ADD_PORT_CODE;
  int n = recvall(client, ((char *) &msg) + 1, sizeof(ctl_msg_add_port_t) - 1);
  assert(n == sizeof(ctl_msg_add_port_t) - 1);
  int status = add_port(msg.iface, msg.port_num);
  send_status_reply(client, msg.request_id, status);
  return 0;
}

static int process_del_port(int client) {
  ctl_msg_del_port_t msg;
  msg.code = CTL_MSG_DEL_PORT_CODE;
  int n = recvall(client, ((char *) &msg) + 1, sizeof(ctl_msg_del_port_t) - 1);
  assert(n == sizeof(ctl_msg_del_port_t) - 1);
  int status = del_port(msg.iface);
  send_status_reply(client, msg.request_id, status);
  return 0;
}

static int process_request(int client) {
  char msg_code;
  int n = recvall(client, &msg_code, 1);
  if (n <= 0) return n;
  switch(msg_code) {
  case CTL_MSG_ADD_PORT_CODE:
    process_add_port(client);
    return CTL_MSG_ADD_PORT_CODE;
  case CTL_MSG_DEL_PORT_CODE:
    process_del_port(client);
    return CTL_MSG_DEL_PORT_CODE;
  default:
    printf("Unknown message format\n");
  }
  return -1;
}

static void *ctl_listen(void *arg) {
  bfns_tcp_over_ip_t listener = *(bfns_tcp_over_ip_t *) arg;

  printf("ctl port: Starting TCP server\n");

  int listenfd,connfd,n;
  struct sockaddr_in servaddr,cliaddr;
  socklen_t clilen;

  listenfd=socket(AF_INET,SOCK_STREAM,0);

  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  /* inet_pton(AF_INET, listener.ip, &servaddr.sin_addr.s_addr); */
  servaddr.sin_addr.s_addr=htonl(INADDR_ANY);
  servaddr.sin_port=htons(listener.port);
  bind(listenfd,(struct sockaddr *)&servaddr,sizeof(servaddr));

  listen(listenfd,1024);

  /* Evrything runs in the same thread -> only one client is expected */
  for(;;)
    {
      clilen=sizeof(cliaddr);
      connfd = accept(listenfd,(struct sockaddr *)&cliaddr,&clilen);
      printf("ctl port: Connection opened\n");

      while((n = process_request(connfd)) > 0);
      printf("ctl port: Connection closed\n");
      close(connfd);
    }
  return NULL;
}

/* Wrapper for transmit operation */
static void
transmit_wrapper(bfm_port_t egress, void *pkt, int len) {
    if (bfm_port_packet_emit(egress, 0, (uint8_t *)pkt, len) < 0) {
        printf("Error sending packet\n");
    }
}


static void
packet_handler(uint32_t port_num, uint8_t *buffer, int length)
{
    /* @fixme log vector */
    printf("Packet in on port %d length %d; first bytes:\n", port_num, length);
    printf("%02x%02x%02x%02x %02x%02x%02x%02x "
           "%02x%02x%02x%02x %02x%02x%02x%02x\n",
           buffer[0], buffer[1], buffer[2], buffer[3],
           buffer[4], buffer[5], buffer[6], buffer[7],
           buffer[8], buffer[9], buffer[10], buffer[11],
           buffer[12], buffer[13], buffer[14], buffer[15]);

    printf("rmt proc returns %d\n", rmt_process_pkt(port_num, buffer, length));
}


static bfm_error_t
lionsgate_init(void)
{
    aim_log_t *aim_log;
    bfm_error_t rv = BFM_E_NONE;

    /* Set debug levels here.  For now, everything on */
    aim_log = aim_log_find("common");
    //    aim_log_flag_set(aim_log, "packet_trace", 1);
    //    aim_log_flag_set(aim_log, "packet_trace_verbose", 1);
    //    aim_log_flag_set(aim_log, "entry_trace", 1);
    aim_log_flag_set(aim_log, "verbose", 1);
    aim_log_flag_set(aim_log, "info", 1);

    bfm_packet_handler_vector_set(packet_handler);

    bfm_port_init(PORT_COUNT);

    return rv;
}

extern int lg_pd_ucli_create(char *prompt);
extern int lg_pd_ucli_thread_spawn(void);


static void
parse_options(int argc, char **argv)
{
  while (1) {
    int option_index = 0;
    /* Options without short equivalents */
    enum long_opts {
      OPT_START = 256,
      OPT_NAME,
      OPT_DPID,
      OPT_VERSION,
      OPT_BFNSDB,
      OPT_NOCLI,
      OPT_NOPCAP,
      OPT_PDSERVER,
      OPT_NOVETH,
    };
    static struct option long_options[] = {
      {"verbose", no_argument, 0, 'v' },
      {"trace", no_argument, 0, 't' },
      {"interface", required_argument, 0, 'i' },
      {"listener", required_argument, 0, 'l' },
      {"dpid", required_argument, 0, OPT_DPID },
      {"help", no_argument, 0, 'h' },
      {"version", no_argument, 0, OPT_VERSION },
      {"name", required_argument, 0, OPT_NAME },
      {"bfnsdb", required_argument, 0, OPT_BFNSDB },
      {"pd-server", required_argument, 0, OPT_PDSERVER },
      {"no-cli", no_argument, 0, OPT_NOCLI },
      {"no-pcap", no_argument, 0, OPT_NOPCAP },
      {"no-veth", no_argument, 0, OPT_NOVETH },
      {0, 0, 0, 0 }
    };
    int c = getopt_long(argc, argv, "vtl:i:h",
                        long_options, &option_index);
    if (c == -1) {
      break;
    }
    switch (c) {
    case 'v':
      assert(0);
      /* loglevel = LOGLEVEL_VERBOSE; */
      break;
    case 't':
      assert(0);
      /* loglevel = LOGLEVEL_TRACE; */
      break;
    case 'l':
      listener_str = strdup(optarg);
      break;
    case 'i':
      interfaces = biglist_append(interfaces, optarg);
      break;
    case OPT_NAME:
      datapath_name = strdup(optarg);
      break;
    case OPT_DPID:
      /* AIM_ASSERT(optarg != NULL, "clang-analyzer workaround"); */
      dpid = strtoll(optarg, NULL, 16);
      break;
    case OPT_VERSION:
      printf("This is the first version ever, duh!\n");
      exit(0);
      break;
    case OPT_BFNSDB:
      bfnsdb_str = strdup(optarg);
      break;
    case OPT_PDSERVER:
      pd_server_str = strdup(optarg);
      break;
    case OPT_NOCLI:
      no_cli = 1;
      break;
    case OPT_NOPCAP:
      dump_pcap = 0;
      break;
    case OPT_NOVETH:
      no_veth = true;
      break;
    case 'h':
    case '?':
      printf("ivs: Barefoot Networks Virtual Switch\n");
      printf("Usage: ivs [OPTION]...\n");
      printf("\n");
      printf(" -v, --verbose Verbose logging\n");
      printf(" -t, --trace Very verbose logging\n");
      printf(" -l, --listener=IP:PORT Listen for bfnctl connections\n");
      printf(" --bfnsdb=IP:PORT Connect to the BFNSDB\n");
      printf(" --pd-server=IP:PORT Listen for PD RPC calls\n");
      printf(" --no-cli Do not start the CLI thread\n");
      printf(" --no-veth No veth interfaces\n");
      printf(" --no-pcap Do not dump to pcap files\n");
      printf(" -i, --interface=INTERFACE Attach a network interface at startup\n");
      printf(" --name=NAME Set the name of the datapath (default bfns)\n");
      printf(" --dpid=DPID Set datapath ID (default autogenerated)\n");
      printf(" -h,--help Display this help message and exit\n");
      printf(" --version Display version information and exit\n");
      exit(c == 'h' ? 0 : 1);
      break;
    }
  }
}


static bfns_db_cxt_t connect_to_bfnsdb() {
  bfns_db_cxt_t c = bfns_db_connect(bfnsdb_addr.ip, bfnsdb_addr.port);
  if(!c) {
    fprintf(stderr, "Could not connect to BFNS DB\n");
    return c;
  }
  fprintf(stderr, "Connected to BFNS DB\n");
  return c;
}

static void clean_up() {
  bfns_db_cxt_t c = bfns_db_connect(bfnsdb_addr.ip, bfnsdb_addr.port);
  if(c) {
    bfns_db_del_datapath(c, datapath_name);
  }
}

static void clean_up_on_signal(int sig) {
  clean_up();
  sigaction(SIGINT, &old_action_SIGINT, NULL);
  sigaction(SIGTERM, &old_action_SIGTERM, NULL);
  raise(sig);
}

int 
aim_main(int argc, char* argv[])
{
    ind_soc_config_t soc;      /* SocketManager configuration. */
    int rv = 0;

    srand (time(NULL));

    parse_options(argc, argv);

    /*************************************************************
     * Check for root access as uses veth interfaces
     * @fixme allow specifying vpi names as runtime config
     ************************************************************/
    if (geteuid() != 0) { 
        fprintf(stderr, "This uses (v)eth interfaces; run under sudo\n");
        return 1; 
    }

    if (!dpid) {
        int r1 = rand();
        int r2 = rand();
        dpid = (((uint64_t) r1) << 32) | ((uint64_t) r2);
    }

    if (!pd_server_str) {
        fprintf(stderr, "No PD RPC server address specified, "
                "using 127.0.0.1:%u\n", PD_SERVER_DEFAULT_PORT);
        parse_connection("127.0.0.1", &pd_server_addr, PD_SERVER_DEFAULT_PORT);
    } else {
        if (parse_connection(pd_server_str, &pd_server_addr,
                             PD_SERVER_DEFAULT_PORT) != 0)
            return -1;
        fprintf(stderr, "PD server address is %s:%u\n",
                pd_server_addr.ip, pd_server_addr.port);
    }

    if (!listener_str) {
        fprintf(stderr, "No listener specified, switch will run in "
                "standalone mode\n");
        if (bfnsdb_str) {
            fprintf(stderr, "BFNSDB will be ignored\n");
            free(bfnsdb_str);
            bfnsdb_str = NULL;
        }
    }

    /*************************************************************
     * Initialize Modules. 
     ************************************************************/
    
    lg_pd_ucli_create("lionsgate");

    CHECK(ind_soc_init(&soc));
    rmt_init();
    CHECK(lionsgate_init());
    rmt_logger_set((bfm_logging_f) printf);
    rmt_log_level_set(BFM_LOG_LEVEL_TRACE);
    rmt_transmit_register(transmit_wrapper);

    /* Start up the RPC server */
    CHECK(start_bfn_pd_rpc_server(pd_server_addr.port));

    // startup another thread for API RPC
#ifdef LIBL2L3_ENABLE
    CHECK(bf_api_init(0));
    CHECK(start_bfn_api_rpc_server());
#endif /* LIBL2L3_DISABLE */

#ifdef NETLINK_ENABLE
    CHECK(start_bfnl_server());
#endif /* NETLINK_ENABLE */

    if (!listener_str && !no_veth) {  /* standalone mode */
      CHECK(bfm_port_interface_add("veth0", 1, datapath_name, dump_pcap));
      CHECK(bfm_port_interface_add("veth2", 2, datapath_name, dump_pcap));
      CHECK(bfm_port_interface_add("veth4", 3, datapath_name, dump_pcap));
      CHECK(bfm_port_interface_add("veth6", 4, datapath_name, dump_pcap));
    }
#ifdef NETLINK_ENABLE
    if (!listener_str) {
        CHECK(bfm_port_interface_add("veth250", 250, datapath_name, dump_pcap));
    }
#endif /* NETLINK_ENABLE */

    if (listener_str) {
        parse_connection(listener_str, &listener_addr, 0);
        if(listener_addr.port == 0) {
            fprintf(stderr, "No port was specified for the listener");
            return -1;
        }

        if (!bfnsdb_str) {
            fprintf(stderr, "No bfnsdb address specified, using 127.0.0.1:%u\n",
                    BFNSDB_DEFAULT_PORT);
            parse_connection("127.0.0.1", &bfnsdb_addr, BFNSDB_DEFAULT_PORT);
        }
        else {
            if (parse_connection(bfnsdb_str, &bfnsdb_addr,
                                 BFNSDB_DEFAULT_PORT) != 0)
                return -1;
            fprintf(stderr, "Bfnsdb address is %s:%u\n",
                    bfnsdb_addr.ip, bfnsdb_addr.port);
        }

        struct sigaction sa;
        sa.sa_handler = clean_up_on_signal;
        sigaction(SIGINT, &sa, &old_action_SIGINT);
        sigaction(SIGTERM, &sa, &old_action_SIGTERM);

        bfns_db_cxt_t c = connect_to_bfnsdb();
        if (!c) return -1;
        if (bfns_db_add_datapath(c, datapath_name, dpid)){
            fprintf(stderr, "BFNSDB: could not create datapath, %s already "
                    "exists\n", datapath_name);
            return -1;
        }
        atexit(clean_up);
        bfns_db_set_listener(c, datapath_name, &listener_addr);

        /* TODO: improve this code */
        uint16_t port_no = 1;
        /* Add interfaces from command line */
        biglist_t *element;
        char *str;
        BIGLIST_FOREACH_DATA(element, interfaces, char *, str) {
            printf("Adding interface %s (port %d)\n", str, port_no);
            if(add_port(str, port_no) < 0) {
                printf("Failed to add interface %s\n", str);
                return -1;
            }
            bfns_db_add_port(c, datapath_name, str, port_no);
            port_no++;
        }

        bfns_db_free(c);

        pthread_create(&ctl_listener_thread, NULL,
                       ctl_listen, (void *) &listener_addr);
    } else if (no_veth) {
        uint16_t port_no = 1;
        biglist_t *element;
        char *str;
        BIGLIST_FOREACH_DATA(element, interfaces, char *, str) {
            printf("Adding interface %s (port %d)\n", str, port_no);
            if(add_port(str, port_no) < 0) {
                printf("Failed to add interface %s\n", str);
                return -1;
            }
            port_no++;
        }
    }

    /*************************************************************
     * Enable All Modules.
     ************************************************************/
    CHECK(ind_soc_enable_set(1));

    /* aim_log_fid_set_all(AIM_LOG_FLAG_TRACE, 1); */

    if(!no_cli) {
      lg_pd_ucli_thread_spawn();
    }

    /*************************************************************
     * Run the Indigo select() loop with no timeout. 
     ************************************************************/
    ind_soc_select_and_run(-1); 

    CHECK(ind_soc_finish()); 
    
    return rv;
}

